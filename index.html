<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gartic Runner 3D - Full Feature Version</title>
    <style>
        /* –°—Ç–∏–ª–∏ –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π */
        body { margin: 0; overflow: hidden; background-color: #000; } canvas { display: block; }
        .ui-panel { position: absolute; background: rgba(10, 20, 40, 0.8); backdrop-filter: blur(5px); padding: 15px; border-radius: 12px; z-index: 100; color: #ecf0f1; border: 1px solid rgba(255, 255, 255, 0.1); box-shadow: 0 4px 20px rgba(0,0,0,0.3); -webkit-user-select: none; user-select: none; font-family: 'Segoe UI', Arial, sans-serif; }
        #stats { top: 20px; left: 20px; } #chat { top: 20px; right: 20px; width: 320px; height: 50vh; min-height: 300px; max-height: 500px; display: flex; flex-direction: column; } #shop { bottom: 20px; left: 20px; width: 250px; } #chatMessages { flex-grow: 1; overflow-y: auto; font-size: 14px; margin-bottom: 10px; scroll-behavior: smooth; } #viewerCount { padding: 8px 12px; font-size: 14px; font-weight: bold; text-align: center; background: #c0392b; border-radius: 8px; margin-bottom: 10px;}
        .overlay { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 200; display: none; text-align: center; flex-direction: column; align-items: center; } .overlay h2 { font-size: 48px; color: #e74c3c; margin-bottom: 10px; }
        .btn { background: #3498db; color: white; border: none; padding: 12px 25px; border-radius: 8px; cursor: pointer; font-size: 18px; margin-top: 20px; font-weight: bold; } .btn-shop { width: 100%; text-align: left; background: #8e44ad; font-size: 14px; padding: 10px 15px; margin: 5px 0 0 0; display: flex; justify-content: space-between; align-items: center; } .btn-shop:hover:not(:disabled) { background: #9b59b6; } .btn-shop:disabled { background: #566573; cursor: not-allowed; opacity: 0.7; } .price { font-weight: normal; opacity: 0.8; }
        .chat-message { margin-bottom: 8px; padding: 6px 10px; border-radius: 8px; background: rgba(255, 255, 255, 0.07); line-height: 1.4; } .fan b { color: #2ecc71; } .troll b { color: #e67e22; } .donation { color: #f1c40f; font-weight: bold; border-left: 4px solid #f1c40f; background: rgba(241, 196, 15, 0.1); } .milestone { color: #2ecc71; font-weight: bold; border-left: 4px solid #2ecc71; background: rgba(46, 204, 113, 0.1); } .cartel-message { color: #e74c3c; font-weight: bold; border-left: 4px solid #e74c3c; background: rgba(231, 76, 60, 0.1); }
        #minigameOverlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); backdrop-filter: blur(8px); z-index: 300; display: none; justify-content: center; align-items: center; } #minigamePanel { background: #1c2833; padding: 25px; border-radius: 15px; border: 2px solid #566573; text-align: center; color: white; box-shadow: 0 10px 40px rgba(0,0,0,0.5); } #minigameTitle { font-size: 28px; margin-bottom: 10px; color: #e74c3c; font-weight: bold; text-transform: uppercase; letter-spacing: 1px; } #minigameStatus { margin-bottom: 20px; font-size: 18px; height: 25px; color: #bdc3c7; } #minigameGrid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; width: 270px; height: 270px; }
        .minigame-btn { width: 100%; height: 100%; background: #34495e; border: 2px solid #2c3e50; border-radius: 10px; cursor: pointer; transition: background 0.1s, transform 0.1s; } .minigame-btn:hover:not(:disabled) { background: #4e6a85; } .minigame-btn.active { background: #3498db; border-color: #5dade2; transform: scale(1.05); } .minigame-btn:disabled { cursor: not-allowed; background: #2c3e50; }
    </style>
</head>
<body>
    <div id="stats" class="ui-panel"> <div id="distanceDisplay">...</div> <div id="balanceDisplay">...</div> </div>
    <div id="chat" class="ui-panel"> <div id="viewerCount">...</div> <div id="chatMessages"></div> </div>
    <div id="shop" class="ui-panel">
        <div style="font-weight: bold; text-align: center;">üõí –ú–∞–≥–∞–∑–∏–Ω –£–ª–æ–≤–æ–∫</div>
        <button class="btn btn-shop" data-item="invincibility"><span>[1] üõ°Ô∏è –ù–µ—É—è–∑–≤–∏–º–æ—Å—Ç—å</span><span class="price">150–†</span></button>
        <button class="btn btn-shop" data-item="magnet"><span>[2] üß≤ –ú–∞–≥–Ω–∏—Ç</span><span class="price">100–†</span></button>
    </div>
    <div id="gameOver" class="ui-panel overlay"> <h2>–ü–û–ô–ú–ê–ù!</h2> <p id="gameOverReason"></p> <p id="finalScore"></p> <button class="btn" onclick="window.location.reload()">üöÄ –ù–æ–≤—ã–π –°—Ç—Ä–∏–º</button> </div>
    <div id="pauseOverlay" class="ui-panel overlay"> <h2 style="color: #f1c40f;">–ü–ê–£–ó–ê</h2> <button id="resumeBtn" class="btn">–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å</button> </div>
    <div id="minigameOverlay"> <div id="minigamePanel"> <div id="minigameTitle">–û–ë–ï–ó–í–†–ï–î–ò–¢–¨ –ë–û–ú–ë–£</div> <div id="minigameStatus">–°–º–æ—Ç—Ä–∏ –≤–Ω–∏–º–∞—Ç–µ–ª—å–Ω–æ...</div> <div id="minigameGrid"> <button class="minigame-btn" data-id="0"></button> <button class="minigame-btn" data-id="1"></button> <button class="minigame-btn" data-id="2"></button> <button class="minigame-btn" data-id="3"></button> <button class="minigame-btn" data-id="4"></button> <button class="minigame-btn" data-id="5"></button> <button class="minigame-btn" data-id="6"></button> <button class="minigame-btn" data-id="7"></button> <button class="minigame-btn" data-id="8"></button> </div> </div> </div>
    <div id="debugIndicator" style="position: absolute; bottom: 10px; right: 10px; color: #f1c40f; font-family: monospace; z-index: 999; display: none; text-shadow: 1px 1px 2px black;">[DEV MODE]</div>
    
    <script type="importmap">{"imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" }}</script>
    <script src="chat.js" defer></script>

    <script type="module">
        import * as THREE from 'three';
        
        if (typeof CHAT_DATA_PAYLOAD === 'undefined') { document.body.innerHTML = `<h1>–û—à–∏–±–∫–∞: –§–∞–π–ª chat.js –Ω–µ –Ω–∞–π–¥–µ–Ω!</h1>`; throw new Error("Game data not found."); }
        const GameConfig = { LANE_WIDTH: 2.5, LANES: [-2.5, 0, 2.5], GROUND_SEGMENT_LENGTH: 10, GROUND_NUM_SEGMENTS: 15, INITIAL_SPEED: 8, GRAVITY: -0.04, JUMP_FORCE: 0.8, SLIDE_DURATION: 40, CHASER_INITIAL_Z: 12, CHASER_SPEED_FACTOR: 0.95, GRENADE_TIMER_MIN: 8, GRENADE_TIMER_MAX: 15, SHOP_ITEMS: { invincibility: { cost: 150, duration: 5000, cooldown: 20000, name: 'üõ°Ô∏è –ù–µ—É—è–∑–≤–∏–º–æ—Å—Ç—å' }, magnet: { cost: 100, duration: 10000, cooldown: 25000, name: 'üß≤ –ú–∞–≥–Ω–∏—Ç' } }, PATTERNS: [ [['jump', 'empty', 'empty']], [['empty', 'slide', 'empty']], [['jump', 'jump', 'empty']], [['slide', 'empty', 'slide']], [['jump', 'empty', 'slide']], [['coin', 'coin', 'coin']], [['empty', 'coin', 'empty']], [['jump', 'coin', 'jump']], [['spikes', 'empty', 'empty']] ], MINIGAME_TRIGGER_DISTANCE: 500 };
        class UIManager { constructor(chatData) { this.chatData = chatData; this.dom = { distance: document.getElementById('distanceDisplay'), balance: document.getElementById('balanceDisplay'), viewerCount: document.getElementById('viewerCount'), chatMessages: document.getElementById('chatMessages'), gameOver: document.getElementById('gameOver'), gameOverReason: document.getElementById('gameOverReason'), finalScore: document.getElementById('finalScore'), pauseOverlay: document.getElementById('pauseOverlay'), shopButtons: document.querySelectorAll('.btn-shop')}; this.lastChatTime = 0; this.nextMilestone = 100; this.viewers = Math.floor(800 + Math.random() * 400); } addChatMessage(username, msg, type = 'fan') { const messageDiv = document.createElement('div'); messageDiv.className = `chat-message ${type}`; messageDiv.innerHTML = `<b>${username}:</b> ${msg}`; this.dom.chatMessages.appendChild(messageDiv); if (this.dom.chatMessages.children.length > 30) this.dom.chatMessages.removeChild(this.dom.chatMessages.firstChild); this.dom.chatMessages.scrollTop = this.dom.chatMessages.scrollHeight; } updateChat(distance, isChaserClose, isGrenadeActive) { const now = Date.now(); if (now - this.lastChatTime > 2500 + Math.random() * 2000) { this.lastChatTime = now; if (isChaserClose && Math.random() < 0.7 && !isGrenadeActive) { const warningMsg = this.chatData.cartel_warnings[Math.floor(Math.random() * this.chatData.cartel_warnings.length)]; this.addChatMessage("–û—á–µ–≤–∏–¥–µ—Ü", warningMsg, 'cartel-message'); } else { const chatter = this.chatData.chatters[Math.floor(Math.random() * this.chatData.chatters.length)]; const message = chatter.messages[Math.floor(Math.random() * chatter.messages.length)]; this.addChatMessage(chatter.name, message, chatter.type); } } if (distance > this.nextMilestone) { let msg = this.chatData.milestones[Math.floor(Math.random() * (this.chatData.milestones.length - 1)) + 1]; this.addChatMessage("–°—Ç—Ä–∏–º-–ë–æ—Ç", msg.replace('{score}', this.nextMilestone), "milestone"); this.viewers += Math.floor(50 + Math.random() * 100); this.nextMilestone *= 2; } this.updateViewerCount(); } updateStats(distance, balance) { this.dom.distance.textContent = `üîù –î–∏—Å—Ç–∞–Ω—Ü–∏—è: ${Math.floor(distance)}–º`; this.dom.balance.textContent = `üí∞ –ë–∞–ª–∞–Ω—Å: ${balance}`; } updateViewerCount() { this.dom.viewerCount.textContent = `üë• –ó—Ä–∏—Ç–µ–ª–∏: ${this.viewers.toLocaleString()}`; } updateShop(effectsManager, currentBalance) { const now = Date.now(); this.dom.shopButtons.forEach(btn => { const itemName = btn.dataset.item; const item = GameConfig.SHOP_ITEMS[itemName]; const nameSpan = btn.querySelector('span:first-child'); btn.disabled = false; nameSpan.innerHTML = `[${btn.dataset.item === 'invincibility' ? '1' : '2'}] ${item.name}`; if (effectsManager.isActive(itemName)) { btn.disabled = true; const timeLeft = Math.ceil((effectsManager.getEffectEndTime(itemName) - now) / 1000); nameSpan.textContent = `–ê–ö–¢–ò–í–ù–û (${timeLeft}—Å)`; } else if (effectsManager.isOnCooldown(itemName)) { btn.disabled = true; const timeLeft = Math.ceil((effectsManager.getCooldownEndTime(itemName) - now) / 1000); nameSpan.textContent = `–ö–î (${timeLeft}—Å)`; } else if (currentBalance < item.cost) { btn.disabled = true; } }); } showGameOver(reason, distance, balance) { this.dom.gameOverReason.textContent = reason; this.dom.finalScore.innerHTML = `üîù ${Math.floor(distance)}–º <br> üí∞ ${balance}`; this.dom.gameOver.style.display = 'flex'; } togglePauseOverlay(show) { this.dom.pauseOverlay.style.display = show ? 'flex' : 'none'; } init() { this.addChatMessage("–°—Ç—Ä–∏–º-–ë–æ—Ç", this.chatData.milestones[0], "milestone"); } }
        class Player { constructor(scene) { this.mesh = new THREE.Mesh(new THREE.CapsuleGeometry(0.5, 0.5, 32), new THREE.MeshStandardMaterial({ color: 0xe74c3c, emissive: 0x550000 })); this.mesh.castShadow = true; this.mesh.position.set(0, 1, 2); scene.add(this.mesh); this.bbox = new THREE.Box3(); this.currentLane = 1; this.verticalVelocity = 0; this.isSliding = false; this.slideTimer = 0; } jump() { if (this.mesh.position.y <= 1.0) this.verticalVelocity = GameConfig.JUMP_FORCE; } slide() { if (!this.isSliding) { this.isSliding = true; this.slideTimer = GameConfig.SLIDE_DURATION; } } move(direction) { if (direction === 'left' && this.currentLane > 0) this.currentLane--; if (direction === 'right' && this.currentLane < 2) this.currentLane++; } update(delta) { this.mesh.position.x += (GameConfig.LANES[this.currentLane] - this.mesh.position.x) * 0.1; this.mesh.position.y += this.verticalVelocity; if (this.mesh.position.y > 1.0) { this.verticalVelocity += GameConfig.GRAVITY; } else { this.mesh.position.y = 1.0; this.verticalVelocity = 0; } if (this.isSliding) { this.mesh.scale.y = 0.5; this.mesh.position.y = 0.5; this.slideTimer--; if (this.slideTimer <= 0) { this.isSliding = false; this.mesh.scale.y = 1; this.mesh.position.y = 1.0; } } this.bbox.setFromObject(this.mesh); } setEmissive(isInvincible) { this.mesh.material.emissive.setHex(isInvincible ? 0x00ff00 : 0x550000); } }
        class EffectsManager { constructor() { this.effects = {}; this.cooldowns = {}; } activate(itemName) { const item = GameConfig.SHOP_ITEMS[itemName]; const now = Date.now(); this.effects[itemName] = now + item.duration; this.cooldowns[itemName] = now + item.cooldown; } isActive(itemName) { return this.effects[itemName] && Date.now() < this.effects[itemName]; } isOnCooldown(itemName) { return this.cooldowns[itemName] && Date.now() < this.cooldowns[itemName]; } getEffectEndTime(itemName) { return this.effects[itemName]; } getCooldownEndTime(itemName) { return this.cooldowns[itemName]; } }
        class MinigameManager { constructor(onCompleteCallback) { this.onComplete = onCompleteCallback; this.dom = { overlay: document.getElementById('minigameOverlay'), status: document.getElementById('minigameStatus'), buttons: document.querySelectorAll('.minigame-btn'),}; this.state = {}; this.dom.buttons.forEach(btn => btn.addEventListener('click', (e) => this.handlePlayerClick(e))); } start(startLevel = 3, totalRounds = 3) { this.state = { isActive: true, isPlayerTurn: false, sequence: [], playerInput: [], currentLevel: startLevel, currentRound: 1, totalRounds: totalRounds, }; this.dom.overlay.style.display = 'flex'; this.playSequence(); } playSequence() { this.state.isPlayerTurn = false; this.state.playerInput = []; this.state.sequence = []; for (let i = 0; i < this.state.currentLevel; i++) { this.state.sequence.push(Math.floor(Math.random() * 9)); } this.dom.status.textContent = `–≠—Ç–∞–ø ${this.state.currentRound}/${this.state.totalRounds}: –ó–∞–ø–æ–º–∏–Ω–∞–π...`; this.dom.buttons.forEach(btn => btn.disabled = true); let i = 0; const interval = setInterval(() => { if (i > 0) this.dom.buttons[this.state.sequence[i-1]].classList.remove('active'); if (i < this.state.sequence.length) { this.dom.buttons[this.state.sequence[i]].classList.add('active'); i++; } else { clearInterval(interval); this.state.isPlayerTurn = true; this.dom.status.textContent = '–¢–≤–æ–π —Ö–æ–¥!'; this.dom.buttons.forEach(btn => btn.disabled = false); } }, 700); } handlePlayerClick(e) { if (!this.state.isPlayerTurn) return; const clickedId = parseInt(e.target.dataset.id); this.state.playerInput.push(clickedId); e.target.classList.add('active'); setTimeout(() => e.target.classList.remove('active'), 200); const lastIndex = this.state.playerInput.length - 1; if (this.state.playerInput[lastIndex] !== this.state.sequence[lastIndex]) { this.end(false); return; } if (this.state.playerInput.length === this.state.sequence.length) { this.state.currentRound++; if (this.state.currentRound > this.state.totalRounds) { this.end(true); } else { this.state.currentLevel++; this.state.isPlayerTurn = false; setTimeout(() => this.playSequence(), 1000); } } } end(isSuccess) { this.state.isActive = false; this.dom.overlay.style.display = 'none'; this.onComplete(isSuccess); } }
        class DebugManager { constructor(game) { this.game = game; this.isActive = false; this.dom = { indicator: document.getElementById('debugIndicator') }; } handleKeyPress(key, code) { if (code === 'Numpad5' || key === '5') { this.toggle(); } if (this.isActive && !this.game.state.isPaused && !this.game.state.isMinigameActive) { this.executeCheat(key); } } toggle() { this.isActive = !this.isActive; this.dom.indicator.style.display = this.isActive ? 'block' : 'none'; if(this.isActive) { this.game.uiManager.addChatMessage('System', 'DEV MODE ACTIVATED', 'milestone'); } else { this.game.uiManager.addChatMessage('System', 'DEV MODE DEACTIVATED', 'cartel-message'); } } executeCheat(key) { switch(key) { case 'm': this.game.state.balance += 1000; this.game.uiManager.addChatMessage('CHEAT', '+1000–†', 'donation'); break; case 'i': this.game.effectsManager.activate('invincibility'); this.game.uiManager.addChatMessage('CHEAT', 'Invincibility ON', 'milestone'); break; case 'k': this.game.gameOver('–°–∞–º–æ—É–Ω–∏—á—Ç–æ–∂–µ–Ω–∏–µ'); break; case '+': case '=': this.game.state.gameSpeed *= 1.2; break; case '-': this.game.state.gameSpeed /= 1.2; break; } } }

        class Game {
            constructor(chatData) {
                this.state = { distance: 0, balance: 0, gameSpeed: GameConfig.INITIAL_SPEED, isGameOver: false, isPaused: false, isMinigameActive: false };
                this.chatData = chatData; this.clock = new THREE.Clock(); this.initEngine(); this.initManagers(); this.initEventListeners();
            }
            initEngine() { this.scene = new THREE.Scene(); this.scene.background = new THREE.Color(0x1a2a3a); this.scene.fog = new THREE.Fog(0x1a2a3a, 15, 70); this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000); this.camera.position.set(0, 2.5, 6); this.renderer = new THREE.WebGLRenderer({ antialias: true }); this.renderer.setSize(window.innerWidth, window.innerHeight); this.renderer.shadowMap.enabled = true; this.renderer.setPixelRatio(window.devicePixelRatio); document.body.appendChild(this.renderer.domElement); const hemiLight = new THREE.HemisphereLight(0xadd8e6, 0x444444, 1.5); this.scene.add(hemiLight); const dirLight = new THREE.DirectionalLight(0xffffff, 1); dirLight.position.set(5, 10, 7); dirLight.castShadow = true; this.scene.add(dirLight); }
            initManagers() {
                this.uiManager = new UIManager(this.chatData);
                this.player = new Player(this.scene);
                this.effectsManager = new EffectsManager();
                this.minigameManager = new MinigameManager(this.onMinigameComplete.bind(this));
                this.debugManager = new DebugManager(this);
                this.initWorld();
            }
            initWorld() { this.groundSegments = []; for (let i = 0; i < GameConfig.GROUND_NUM_SEGMENTS; i++) { const ground = new THREE.Mesh(new THREE.PlaneGeometry(GameConfig.LANE_WIDTH * 3 + 2, GameConfig.GROUND_SEGMENT_LENGTH), new THREE.MeshStandardMaterial({ color: 0x444444 })); ground.rotation.x = -Math.PI / 2; ground.position.z = -i * GameConfig.GROUND_SEGMENT_LENGTH + GameConfig.GROUND_SEGMENT_LENGTH / 2; ground.receiveShadow = true; this.scene.add(ground); this.groundSegments.push(ground); } this.activeObjects = []; this.spawnTimer = 0; this.chaserZ = GameConfig.CHASER_INITIAL_Z; this.grenadeTimer = GameConfig.GRENADE_TIMER_MIN + Math.random() * (GameConfig.GRENADE_TIMER_MAX - GameConfig.GRENADE_TIMER_MIN); this.grenade = null; this.landingMarker = null; this.tickAudio = new Audio(); this.shakeFrames = 0; this.shakeIntensity = 0; this.nextMinigameDistance = GameConfig.MINIGAME_TRIGGER_DISTANCE; }
            initEventListeners() { window.addEventListener('resize', this.onWindowResize.bind(this)); document.addEventListener('keydown', this.handleInput.bind(this)); document.getElementById('resumeBtn').addEventListener('click', () => this.togglePause()); document.querySelectorAll('.btn-shop').forEach(btn => btn.addEventListener('click', () => this.buyItem(btn.dataset.item))); }
            start() { this.uiManager.init(); this.animate(); }
            
            animate() {
                requestAnimationFrame(this.animate.bind(this));
                if (this.state.isGameOver || this.state.isPaused || this.state.isMinigameActive) {
                    this.renderer.render(this.scene, this.camera);
                    return;
                }
                const delta = this.clock.getDelta();
                this.state.distance += this.state.gameSpeed * delta;
                
                if (this.state.distance >= this.nextMinigameDistance) {
                    this.startMinigame();
                    return;
                }

                this.player.mesh.position.z -= this.state.gameSpeed * delta; this.player.update(delta); this.updateWorld(delta); this.checkCollisions(); this.updateChaser(delta); this.grenadeTimer -= delta; if (this.grenadeTimer <= 0) { this.throwGrenade(); this.grenadeTimer = GameConfig.GRENADE_TIMER_MIN + Math.random() * (GameConfig.GRENADE_TIMER_MAX - GameConfig.GRENADE_TIMER_MIN); } this.updateGrenade(delta); this.updateCamera(); this.player.setEmissive(this.effectsManager.isActive('invincibility')); const isChaserClose = this.chaserZ - this.player.mesh.position.z < 12; this.uiManager.updateChat(this.state.distance, isChaserClose, !!this.grenade); this.uiManager.updateStats(this.state.distance, this.state.balance); this.uiManager.updateShop(this.effectsManager, this.state.balance); this.renderer.render(this.scene, this.camera);
            }
            
            startMinigame() { this.state.isMinigameActive = true; if(this.tickAudio && !this.tickAudio.paused) this.tickAudio.pause(); this.uiManager.addChatMessage("–ö–∞—Ä—Ç–µ–ª—å", "–û–Ω–∏ —á—Ç–æ-—Ç–æ –∑–∞–ª–æ–∂–∏–ª–∏! –ù—É–∂–Ω–æ –æ–±–µ–∑–≤—Ä–µ–¥–∏—Ç—å!", 'cartel-message'); this.minigameManager.start(3, 3); }
            onMinigameComplete(isSuccess) {
                if (isSuccess) { this.state.balance += 300; this.uiManager.addChatMessage("–°—Ç—Ä–∏–º-–ë–æ—Ç", "–ë–æ–º–±–∞ –æ–±–µ–∑–≤—Ä–µ–∂–µ–Ω–∞! +300–† –∫ –±–∞–ª–∞–Ω—Å—É!", 'donation');
                } else { this.chaserZ -= 5; this.uiManager.addChatMessage("–ö–∞—Ä—Ç–µ–ª—å", "–û–Ω–∏ —É—Å–ø–µ–ª–∏ –ø–µ—Ä–µ–¥–∞—Ç—å —Ç–≤–æ–∏ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã! –û–Ω–∏ –±–ª–∏–∂–µ!", 'cartel-message'); this.shakeScreen(15, 0.08); }
                this.state.isMinigameActive = false; this.nextMinigameDistance += GameConfig.MINIGAME_TRIGGER_DISTANCE;
                if(this.grenade && !this.tickAudio.paused) this.tickAudio.play();
            }
            
            handleInput(event) {
                this.debugManager.handleKeyPress(event.key, event.code);
                if (event.key === 'Escape') this.togglePause();
                if (this.state.isGameOver || this.state.isPaused || this.state.isMinigameActive) return;
                switch (event.key) {
                    case 'ArrowLeft': this.player.move('left'); break;
                    case 'ArrowRight': this.player.move('right'); break;
                    case 'ArrowUp': case ' ': this.player.jump(); break;
                    case 'ArrowDown': this.player.slide(); break;
                    case '1': this.buyItem('invincibility'); break;
                    case '2': this.buyItem('magnet'); break;
                }
            }

            // ... –û—Å—Ç–∞–ª—å–Ω—ã–µ –º–µ—Ç–æ–¥—ã –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π ...
            buyItem(itemName) { if (this.state.isPaused || this.state.isGameOver || this.state.isMinigameActive) return; const item = GameConfig.SHOP_ITEMS[itemName]; if (this.state.balance >= item.cost && !this.effectsManager.isOnCooldown(itemName)) { this.state.balance -= item.cost; this.effectsManager.activate(itemName); } }
            updateWorld(delta) { this.groundSegments.forEach(seg => { seg.position.z += this.state.gameSpeed * delta; if (seg.position.z > this.camera.position.z + GameConfig.GROUND_SEGMENT_LENGTH) seg.position.z -= GameConfig.GROUND_SEGMENT_LENGTH * GameConfig.GROUND_NUM_SEGMENTS; }); for (let i = this.activeObjects.length - 1; i >= 0; i--) { const obj = this.activeObjects[i]; obj.position.z += this.state.gameSpeed * delta; if (obj.userData.type === 'collectible' && this.effectsManager.isActive('magnet') && obj.position.distanceTo(this.player.mesh.position) < 8) obj.position.x += (this.player.mesh.position.x - obj.position.x) * 0.1; if (obj.userData.type === 'damageZone') { obj.userData.lifetime -= delta; obj.material.opacity = 0.5 * (obj.userData.lifetime / 4); if (obj.userData.lifetime <= 0) { this.scene.remove(obj); this.activeObjects.splice(i, 1); continue; } } else if (obj.position.z > this.camera.position.z + 2) { this.scene.remove(obj); this.activeObjects.splice(i, 1); } } this.spawnTimer -= delta; if (this.spawnTimer <= 0) this.spawnPattern(); }
            spawnPattern() { const spawnZ = this.player.mesh.position.z - 50; let chosenPattern = GameConfig.PATTERNS[Math.floor(Math.random() * GameConfig.PATTERNS.length)][0].slice(); for (let i = chosenPattern.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [chosenPattern[i], chosenPattern[j]] = [chosenPattern[j], chosenPattern[i]]; } let hasSpikes = false; for (let i = 0; i < 3; i++) { const type = chosenPattern[i]; let newObject = null; switch (type) { case 'jump': newObject = new THREE.Mesh(new THREE.BoxGeometry(GameConfig.LANE_WIDTH - 0.5, 1.5, 1), new THREE.MeshStandardMaterial({ color: 0x992222 })); newObject.position.set(GameConfig.LANES[i], 0.75, spawnZ); newObject.userData = { type: 'obstacle', subtype: 'jump' }; break; case 'slide': newObject = new THREE.Mesh(new THREE.BoxGeometry(GameConfig.LANE_WIDTH - 0.5, 0.4, 1), new THREE.MeshStandardMaterial({ color: 0x992222 })); newObject.position.set(GameConfig.LANES[i], 1.5, spawnZ); newObject.userData = { type: 'obstacle', subtype: 'slide' }; break; case 'coin': newObject = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.4, 0.15, 24), new THREE.MeshStandardMaterial({ color: 0xf1c40f, emissive: 0xccaa00 })); newObject.position.set(GameConfig.LANES[i], 1, spawnZ); newObject.userData = { type: 'collectible' }; break; case 'spikes': this.createSpikeTrap(i, this.player.mesh.position.z - 25); hasSpikes = true; break; } if (newObject) { newObject.castShadow = true; this.activeObjects.push(newObject); this.scene.add(newObject); } } this.spawnTimer = hasSpikes ? 3.0 : Math.max(0.7, 1.8 - this.state.distance / 500); }
            checkCollisions() { for (let i = this.activeObjects.length - 1; i >= 0; i--) { const obj = this.activeObjects[i]; const currentBBox = new THREE.Box3().setFromObject(obj); if (this.player.bbox.intersectsBox(currentBBox)) { if (obj.userData.type === 'collectible') { const donation = this.chatData.donations[Math.floor(Math.random() * this.chatData.donations.length)]; this.state.balance += donation.amount; this.uiManager.addChatMessage("–©–µ–¥—Ä—ã–π –ó—Ä–∏—Ç–µ–ª—å", donation.message.replace('{amount}', donation.amount), "donation"); this.scene.remove(obj); this.activeObjects.splice(i, 1); } else if (!this.effectsManager.isActive('invincibility')) { if (obj.userData.type === 'obstacle') { if (this.player.isSliding && obj.userData.subtype === 'slide') continue; this.gameOver("–ù–∞—Ç–∫–Ω—É–ª—Å—è –Ω–∞ –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–µ!"); } else if (obj.userData.type === 'damageZone') { this.gameOver("–ü–æ–ø–∞–ª –ø–æ–¥ –≤–∑—Ä—ã–≤!"); } } } } }
            updateChaser(delta) { this.chaserZ -= this.state.gameSpeed * GameConfig.CHASER_SPEED_FACTOR * delta; if (this.chaserZ <= this.player.mesh.position.z) this.gameOver("–ö–∞—Ä—Ç–µ–ª—å —Ç–µ–±—è –¥–æ–≥–Ω–∞–ª!"); }
            updateCamera() { if (this.shakeFrames > 0) { const originalZ = this.player.mesh.position.z + 4; this.camera.position.x = (Math.random() - 0.5) * this.shakeIntensity; this.camera.position.y = 2.5 + (Math.random() - 0.5) * this.shakeIntensity; this.camera.position.z = originalZ + (Math.random() - 0.5) * this.shakeIntensity; this.shakeFrames--; } else { this.camera.position.set(0, 2.5, this.player.mesh.position.z + 4); } }
            togglePause() { if (this.state.isGameOver || this.state.isMinigameActive) return; this.state.isPaused = !this.state.isPaused; this.uiManager.togglePauseOverlay(this.state.isPaused); if (this.state.isPaused) { if(this.tickAudio) this.tickAudio.pause(); } else if (this.grenade) { this.tickAudio.play(); } }
            gameOver(reason) { this.state.isGameOver = true; this.state.gameSpeed = 0; if(this.tickAudio) this.tickAudio.pause(); this.uiManager.showGameOver(reason, this.state.distance, this.state.balance); }
            onWindowResize() { this.camera.aspect = window.innerWidth / window.innerHeight; this.camera.updateProjectionMatrix(); this.renderer.setSize(window.innerWidth, window.innerHeight); }
            playSound(src) { new Audio(src).play(); }
            shakeScreen(frames, intensity) { this.shakeFrames = frames; this.shakeIntensity = intensity; }
            throwGrenade() { if (this.grenade || this.state.isMinigameActive) return; const targetLane = Math.floor(Math.random() * 3); const targetZ = this.player.mesh.position.z - 20; this.grenade = new THREE.Mesh(new THREE.SphereGeometry(0.3, 8, 8), new THREE.MeshStandardMaterial({ color: 0x222222 })); this.grenade.position.set(GameConfig.LANES[this.player.currentLane], this.player.mesh.position.y + 1, this.player.mesh.position.z); this.grenade.userData.velocity = new THREE.Vector3((GameConfig.LANES[targetLane] - this.grenade.position.x) * 0.1, 3.5, -this.state.gameSpeed * 1.5); this.scene.add(this.grenade); this.landingMarker = new THREE.Mesh(new THREE.RingGeometry(0.8, 1, 32), new THREE.MeshBasicMaterial({ color: 0xff0000, side: THREE.DoubleSide, transparent: true })); this.landingMarker.position.set(GameConfig.LANES[targetLane], 0.01, targetZ); this.landingMarker.rotation.x = -Math.PI / 2; this.scene.add(this.landingMarker); this.tickAudio.src = 'tick.mp3'; this.tickAudio.loop = true; this.tickAudio.volume = 0.3; this.tickAudio.play().catch(e => {}); }
            updateGrenade(delta) { if (!this.grenade) return; this.grenade.position.addScaledVector(this.grenade.userData.velocity, delta); this.grenade.userData.velocity.y -= 9.8 * delta; if (this.landingMarker) this.landingMarker.material.opacity = 0.5 + Math.sin(Date.now() * 0.01) * 0.5; if (!this.tickAudio.paused) this.tickAudio.volume = Math.min(1.0, this.tickAudio.volume + 0.05 * delta); if (this.grenade.position.y <= 0.1) { this.createDamageZone(this.landingMarker.position.x, this.landingMarker.position.z); this.scene.remove(this.grenade); this.scene.remove(this.landingMarker); this.grenade = null; this.landingMarker = null; this.shakeScreen(10, 0.05); this.tickAudio.pause(); this.playSound('explosion.mp3'); } }
            createDamageZone(x, z) { const zoneGeo = new THREE.CylinderGeometry(GameConfig.LANE_WIDTH / 2, GameConfig.LANE_WIDTH / 2, 3, 16, 1, true); const zoneMat = new THREE.MeshBasicMaterial({ color: 0xff4500, transparent: true, opacity: 0.5, side: THREE.DoubleSide }); const damageZone = new THREE.Mesh(zoneGeo, zoneMat); damageZone.position.set(x, 1.5, z); damageZone.userData = { type: 'damageZone', lifetime: 4 }; this.activeObjects.push(damageZone); this.scene.add(damageZone); }
            createSpikeTrap(lane, startZ) { const spikeGeo = new THREE.ConeGeometry(0.4, 1.0, 8); const spikeMat = new THREE.MeshStandardMaterial({ color: 0x888899, metalness: 0.8, roughness: 0.4 }); for (let i = 0; i < 6; i++) { const spike = new THREE.Mesh(spikeGeo, spikeMat); spike.position.set(GameConfig.LANES[lane], 0.5, startZ - i * 4.0); spike.castShadow = true; spike.userData = { type: 'obstacle' }; this.activeObjects.push(spike); this.scene.add(spike); } const warningMsg = this.chatData.spike_warnings[Math.floor(Math.random() * this.chatData.spike_warnings.length)]; this.uiManager.addChatMessage("–û—á–µ–≤–∏–¥–µ—Ü", warningMsg, 'cartel-message'); }
        }

        const game = new Game(CHAT_DATA_PAYLOAD);
        game.start();

    </script>
</body>
</html>